import datetime
import ckanext.ytp.comments.model as comment_model
import ckanext.ytp.comments.util as util
from ckan import logic
from pprint import pprint
import logging
import ckan.plugins.toolkit as toolkit

log = logging.getLogger(__name__)

EMAIL_NOTIFY_OFFICIAL_COMMENT_CREATE = """Dear Energydata.info Team,

A new comment has been posted on ENERGYDATA.INFO.

By user: {2}
Comment: {0}

Click to view the thread at {1}

This mail was automatically generated by CKAN at Energydata.info

Have a great day!
"""


def notify_official(dataset, usrobj, comment=False):
    '''
    Notify a CKAN user that a comment has been successfully created.
    '''
    # from pylons import config
    from ckan.common import config

    # if not tk.asbool(config.get('ckanext.datarequests.send_emails')):
    #     return
    site_url = config.get('ckan.site_url', '')
    request_dataset_url = site_url + "/dataset/" + dataset.name

    import ckan.lib.mailer

    email_dict = dict()
    email_dict['name'] = 'Energydata.info'
    officials_emails = ['jodie@derilinx.com', 'energydata@worldbankgroup.org']

    if comment:
        email_dict['subject'] = "New Comment on a Dataset on Energydata.info"
        email_dict['body'] = EMAIL_NOTIFY_OFFICIAL_COMMENT_CREATE.format(comment.comment, request_dataset_url, usrobj.name)
    else:
        email_dict['subject'] = "no subject"
        email_dict['body'] = EMAIL_NOTIFY_OFFICIAL_STATUS_CREATE % request_dataset_url

    for email in officials_emails:
        if email:
            email_dict['email'] = email
            try:
                ckan.lib.mailer.mail_recipient(email_dict['name'], email_dict['email'],
                                               email_dict['subject'], email_dict['body'])
                log.info("Successfully notified official %s for dataset comment %s" % (email, dataset.id))
            except ckan.lib.mailer.MailerException:
                log.error("Failed to notify official %s for dataset comment %s" % (email, dataset.id))


def comment_create(context, data_dict):
    pprint(data_dict)
    pprint(context)
    model = context['model']
    user = context['user']
    package = context['package']

    userobj = model.User.get(user)

    logic.check_access("comment_create", context, data_dict)

    # Validate that we have the required fields.
    if not all([data_dict.get('comment')]):
        raise logic.ValidationError("Comment text is required")

    thread_id = data_dict.get('thread_id')

    if not thread_id:
        url = data_dict.get('url')
        if url:
            thread = comment_model.CommentThread.from_url(url)
            thread_id = thread.id if thread else None

    if not thread_id:
        raise logic.ValidationError("Thread identifier or URL is required")

    # Cleanup the comment
    cleaned_comment = util.clean_input(data_dict.get('comment'))

    # Create the object
    cmt = comment_model.Comment(thread_id=thread_id,
                                comment=cleaned_comment)
    cmt.user_id = userobj.id
    cmt.subject = data_dict.get('subject', '')

    if 'creation_date' in context:
        cmt.creation_date = datetime.datetime.fromtimestamp(context['creation_date'])

    # Check if there is a parent ID and that it is valid
    # TODO, validity in this case includes checking parent is not
    # deleted.
    prt = data_dict.get('parent_id')
    if prt:
        parent = comment_model.Comment.get(prt)
        if parent:
            cmt.parent_id = parent.id

    # approval and spam checking removed

    model.Session.add(cmt)
    model.Session.commit()

    # Notify energydata team

    notify_official(package, userobj, comment=cmt)

    return cmt.as_dict()
